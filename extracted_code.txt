==================================================================================
PH·∫¶N 1: BACKEND (Python - server.py)
==================================================================================

from fastapi import FastAPI, File, UploadFile
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from PIL import Image
import numpy as np
import io
import tensorflow as tf
import base64
import cv2

app = FastAPI()

# ==========================================
# ‚öôÔ∏è C·∫§U H√åNH CORS
# ==========================================
origins = ["*"]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ==========================================
# ‚öôÔ∏è C·∫§U H√åNH MODEL
# ==========================================
MODEL_FILE = "skin_vgg16_model.keras"
IMG_SIZE = (224, 224)
INNER_MODEL_NAME = "vgg16"
LAST_CONV_LAYER_NAME = "block5_conv3"

CLASS_NAMES = [
    'Actinic keratoses (akiec)',
    'Basal cell carcinoma (bcc)',
    'Benign keratosis-like lesions (bkl)',
    'Dermatofibroma (df)',
    'Melanoma (mel)',
    'Melanocytic nevi (nv)',
    'Vascular lesions (vasc)'
]

print(f"‚è≥ ƒêang t·∫£i model: {MODEL_FILE}...")
try:
    model = tf.keras.models.load_model(MODEL_FILE)
    print("‚úÖ Model t·∫£i th√†nh c√¥ng!")
except Exception as e:
    print(f"‚ùå L·ªñI T·∫£i Model: {e}")
    model = None

# --- H√ÄM T√çNH GRAD-CAM (D·ª±a tr√™n HEATMAP.py) ---
def compute_gradcam(model, img_array, class_index, inner_layer_name="vgg16", conv_layer_name="block5_conv3"):
    try:
        # L·∫•y model con VGG16
        inner_model = model.get_layer(inner_layer_name)
        
        # T·∫°o grad_model t·ª´ input c·ªßa model con -> [conv_output, model_output]
        grad_model = tf.keras.models.Model(
            inputs=inner_model.input,
            outputs=[inner_model.get_layer(conv_layer_name).output, inner_model.output]
        )

        with tf.GradientTape() as tape:
            # T√≠nh to√°n tr√™n model con
            conv_outputs, predictions = grad_model(img_array)
            
            # Logic Activation Map (An to√†n nh·∫•t cho model l·ªìng)
            # L·∫•y trung b√¨nh c√°c feature map
            loss = predictions[:, class_index]

        # T√≠nh gradient c·ªßa loss theo output c·ªßa conv layer
        grads = tape.gradient(loss, conv_outputs)

        # T√≠nh global average pooling c·ªßa gradients
        pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))

        # Nh√¢n feature map v·ªõi weight (pooled gradients)
        heatmap = conv_outputs[0] @ pooled_grads[..., tf.newaxis]
        heatmap = tf.squeeze(heatmap)

        # QUAY V·ªÄ LOGIC ACTIVATION MAP
        heatmap = tf.maximum(heatmap, 0)
        
        max_val = tf.math.reduce_max(heatmap)
        if max_val == 0: return heatmap.numpy()
        
        heatmap = heatmap / max_val
        return heatmap.numpy()

    except Exception as e:
        print(f"‚ö†Ô∏è L·ªói t√≠nh Heatmap: {e}")
        return np.zeros((IMG_SIZE[0], IMG_SIZE[1]))

def overlay_heatmap_cv2(img_pil, heatmap, alpha=0.4):
    """
    H√†m ch·ªìng ·∫£nh d√πng OpenCV (ƒë√£ s·ª≠a l·ªói m√†u s·∫Øc)
    """
    try:
        # 1. Chuy·ªÉn PIL (RGB) sang NumPy (RGB)
        img = np.array(img_pil)
        
        # 2. Resize heatmap v·ªÅ k√≠ch th∆∞·ªõc ·∫£nh g·ªëc
        heatmap = cv2.resize(heatmap, (img.shape[1], img.shape[0]))
        
        # 3. Chu·∫©n h√≥a heatmap sang 0-255 (uint8)
        heatmap = np.uint8(255 * heatmap)
        
        # 4. T·∫°o b·∫£n ƒë·ªì m√†u (ColorMap)
        # L∆∞u √Ω: applyColorMap tr·∫£ v·ªÅ BGR theo chu·∫©n OpenCV
        heatmap_colored = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
        
        # 5. Chuy·ªÉn Heatmap t·ª´ BGR sang RGB ƒë·ªÉ kh·ªõp v·ªõi ·∫£nh g·ªëc (PIL)
        heatmap_colored = cv2.cvtColor(heatmap_colored, cv2.COLOR_BGR2RGB)
        
        # 6. Pha tr·ªôn (Blend)
        # img l√† RGB, heatmap_colored c≈©ng l√† RGB -> K·∫øt qu·∫£ ƒë√∫ng m√†u
        superimposed_img = cv2.addWeighted(img, alpha, heatmap_colored, 1 - alpha, 0)
        
        # 7. Tr·∫£ v·ªÅ PIL Image
        return Image.fromarray(superimposed_img)
        
    except Exception as e:
        print(f"L·ªói overlay: {e}")
        return img_pil # Tr·∫£ v·ªÅ ·∫£nh g·ªëc n·∫øu l·ªói

def pil_image_to_base64(image):
    buffered = io.BytesIO()
    image.save(buffered, format="PNG")
    return base64.b64encode(buffered.getvalue()).decode("utf-8")

@app.get("/")
def home():
    return {"status": "Skin-AI Server Running (Fixed Color Logic)"}

@app.post("/explain")
async def explain_image(file: UploadFile = File(...)):
    if model is None:
        return JSONResponse(content={"error": "Model ch∆∞a t·∫£i"}, status_code=500)

    try:
        # 1. ƒê·ªçc v√† Ti·ªÅn x·ª≠ l√Ω (Code x·ª≠ l√Ω ·∫£nh ƒë·∫ßu v√†o)
        image_data = await file.read()
        image_pil = Image.open(io.BytesIO(image_data)).convert("RGB")
        img_tensor = image_pil.resize(IMG_SIZE)
        img_array = np.array(img_tensor)
        img_array = np.expand_dims(img_array, axis=0) / 255.0

        print(f"üîç Ph√¢n t√≠ch ·∫£nh shape: {img_array.shape}")

        # 2. D·ª± ƒëo√°n (Code Predict)
        predictions = model.predict(img_array)
        scores = predictions[0]
        predicted_index = np.argmax(scores)
        predicted_class = CLASS_NAMES[predicted_index]
        confidence = float(scores[predicted_index])

        # Chi ti·∫øt
        detailed_results = []
        for i, score in enumerate(scores):
            detailed_results.append({
                "disease": CLASS_NAMES[i],
                "probability": float(score) * 100,
                "score": float(score)
            })
        detailed_results.sort(key=lambda x: x["probability"], reverse=True)

        # 3. T·∫°o Heatmap
        heatmap = compute_gradcam(
            model,
            img_array,
            predicted_index,
            inner_layer_name=INNER_MODEL_NAME,
            conv_layer_name=LAST_CONV_LAYER_NAME
        )
        
        # Overlay: D√πng ·∫£nh g·ªëc ƒë√£ resize ƒë·ªÉ hi·ªÉn th·ªã ƒë·∫πp
        display_img = image_pil.resize(IMG_SIZE)
        result_img = overlay_heatmap_cv2(display_img, heatmap, alpha=0.4)

        # Base64
        heatmap_base64_str = pil_image_to_base64(result_img)

        # 4. Tr·∫£ v·ªÅ JSON (Code hi·ªÉn th·ªã k·∫øt qu·∫£)
        return JSONResponse(content={
            "status": "success",
            "prediction": {
                "class": predicted_class,
                "confidence": f"{confidence * 100:.2f}%",
                "confidence_score": confidence
            },
            "details": detailed_results,
            "heatmap_image": heatmap_base64_str
        })

    except Exception as e:
        print(f"‚ùå L·ªói X·ª≠ l√Ω Server: {e}")
        import traceback
        traceback.print_exc()
        return JSONResponse(content={"status": "error", "message": str(e)}, status_code=500)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)


==================================================================================
